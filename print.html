<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>An In-Depth Guide to Windows File Paths</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="Overview.html"><strong aria-hidden="true">1.</strong> Overview</a></li><li class="chapter-item expanded "><a href="Details.html"><strong aria-hidden="true">2.</strong> Parsing Details</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="NT.html"><strong aria-hidden="true">2.1.</strong> NT Kernel Paths</a></li><li class="chapter-item expanded "><a href="Strings.html"><strong aria-hidden="true">2.2.</strong> Strings</a></li><li class="chapter-item expanded "><a href="Filesystems.html"><strong aria-hidden="true">2.3.</strong> Filesystems</a></li><li class="chapter-item expanded "><a href="Win32.html"><strong aria-hidden="true">2.4.</strong> Win32 Paths</a></li><li class="chapter-item expanded "><a href="Special Dos Device Names.html"><strong aria-hidden="true">2.5.</strong> Special Dos Device Names</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">An In-Depth Guide to Windows File Paths</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="overview"><a class="header" href="#overview">Overview</a></h1>
<h2 id="win32-paths"><a class="header" href="#win32-paths">Win32 Paths</a></h2>
<p><a href="./Win32.html">Win32 paths</a> are a living history of Microsoft OSes from DOS 1.0 through Windows 95/NT and modern Windows.</p>
<h3 id="absolute-win32-paths"><a class="header" href="#absolute-win32-paths">Absolute Win32 paths</a></h3>
<table><thead><tr><th>Type</th><th>Examples</th></tr></thead><tbody>
<tr><td>Drive</td><td><code>C:\Windows</code></td></tr>
<tr><td><abbr title="Universal Naming Convention">UNC</abbr></td><td><code>\\server\share\</code></td></tr>
<tr><td>Device</td><td><code>\\.\PIPE\name</code></td></tr>
<tr><td>Verbatim</td><td><code>\\?\C:\Windows</code><br><code>\\?\UNC\server\share\</code><br><code>\\?\PIPE\name</code></td></tr>
</tbody></table>
<h3 id="relative-win32-paths"><a class="header" href="#relative-win32-paths">Relative Win32 paths</a></h3>
<table><thead><tr><th>Type</th><th>Examples</th></tr></thead><tbody>
<tr><td>Path Relative</td><td><code>file.ext</code><br><code>.\file.ext</code><br><code>..\file.ext</code></td></tr>
<tr><td>Root Relative</td><td><code>\file.ext</code></td></tr>
<tr><td>Drive Relative</td><td><code>D:file.ext</code></td></tr>
</tbody></table>
<h2 id="path-character-encoding"><a class="header" href="#path-character-encoding">Path character encoding</a></h2>
<p>Paths are <a href="./Strings.html">UTF-16 strings</a>. Windows allows using other encodings (including UTF-8) but these are all lossily converted to and from UTF-16.</p>
<h2 id="disallowed-characters"><a class="header" href="#disallowed-characters">Disallowed characters</a></h2>
<p><a href="./Filesystems.html">Filesystem drivers</a> typically disallow the following characters in path components:</p>
<table><thead><tr><th>Disallowed</th><th>Description</th></tr></thead><tbody>
<tr><td><code>\</code> <code>/</code></td><td>Path seperators</td></tr>
<tr><td><code>:</code></td><td>Dos drive and NTFS file stream separator</td></tr>
<tr><td><code>*</code> <code>?</code></td><td>Wildcards</td></tr>
<tr><td><code>&lt;</code> <code>&gt;</code> <code>&quot;</code></td><td>DOS wildcards</td></tr>
<tr><td><code>|</code></td><td>Pipe</td></tr>
<tr><td><code>NUL</code> to <code>US</code></td><td>ASCII control codes; aka Unicode C0 control codes (U+0000 to U+001F inclusive). Note that <code>DEL</code> (U+007F) is allowed.</td></tr>
</tbody></table>
<p>Note that path separators and wildcards must be disallowed in normal filesystems otherwise some Win32 APIs will be unusable in some situations.</p>
<h2 id="special-dos-device-names"><a class="header" href="#special-dos-device-names">Special Dos Device Names</a></h2>
<p>For legacy reasons, some filenames may be interpreted as <a href="./Special%20Dos%20Device%20Names.html">DOS devices</a>. This means, for example the path &quot;AUX&quot; will be rewritten as <code>\\.\AUX</code>.</p>
<p>The following are special dos device names:</p>
<ul>
<li><code>AUX</code></li>
<li><code>CON</code></li>
<li><code>CONIN$</code></li>
<li><code>CONOUT$</code></li>
<li><code>COM1</code>, <code>COM2</code>, <code>COM3</code>, <code>COM4</code>, <code>COM5</code>, <code>COM6</code>, <code>COM7</code>, <code>COM8</code>, <code>COM9</code>, <code>COM²</code>, <code>COM³</code>, <code>COM¹</code></li>
<li><code>LPT1</code>, <code>LPT2</code>, <code>LPT3</code>, <code>LPT4</code>, <code>LPT5</code>, <code>LPT6</code>, <code>LPT7</code>, <code>LPT8</code>, <code>LPT9</code>, <code>LPT²</code>, <code>LPT³</code>, <code>LPT¹</code></li>
<li><code>NUL</code></li>
<li><code>PRN</code></li>
</ul>
<p>Note that these names are case-insensitive though canonically they're uppercase.</p>
<h2 id="under-the-hood"><a class="header" href="#under-the-hood">Under the hood</a></h2>
<p>Win32 paths are emulated on top of <a href="./NT.html">NT kernel paths</a>. An NT path looks similar to a Unix path, except for the directory separator. For example:</p>
<pre><code>\Device\HarddiskVolume2\directory\subdir\file.ext
</code></pre>
<p>These types of paths cannot be used directly in the Win32 API but can make themsevles apparent in other ways.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="details"><a class="header" href="#details">Details</a></h1>
<p>This section contains everything you ever wanted to know about Windows paths but were afraid to ask. Note that this discusses internal details that may be subject to change. It is intended to document the current state of path parsing in Windows and so not every detail can be relied on to always be true.</p>
<p>I'll start with NT kernel paths. These aren't usually used directly from user space but I promise they're important to fully understanding Win32 paths.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nt-kernel"><a class="header" href="#nt-kernel">NT Kernel</a></h1>
<p>If everything in Unix is a file, then everything in NT is an object<sup class="footnote-reference"><a href="#1">1</a></sup>. And if that object is named then it can be accessed via the NT kernel's Object Manager.</p>
<p>For people using the Win32 APIs this is technically an implementation detail but, when it comes to file paths at least, it's a very leaky one. Understanding how paths are handled at this level will help understand Win32 paths as well.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>This isn't quite true for either.</p>
</div>
<h2 id="nt-paths"><a class="header" href="#nt-paths">NT Paths</a></h2>
<p>The kernel uses paths to query named objects in the object manager. These look similar to a UNIX path. For example:</p>
<pre><code>\Device\HarddiskVolume2
</code></pre>
<p>A path is made up of &quot;components&quot;, separated by a <code>\</code>. Each component represents a directory name or a file name. In NT, components are arrays of <a href="Strings.html">16-bit code units</a>. Any character except <code>\</code> (<code>0x005C</code>) is allowed in component names. Even <code>NULL</code> (<code>0x0000</code>) is allowed.</p>
<p>Starting a path with a <code>\</code> indicates that it starts from the root. It's an absolute path.</p>
<h3 id="relative-paths"><a class="header" href="#relative-paths">Relative paths</a></h3>
<p>If a directory is opened, kernel APIs allow you to open sub paths based on that directory. For example if you open the directory:</p>
<pre><code>\Device\HarddiskVolume2\directory
</code></pre>
<p>You can then use the directory handle to open a relative path, such as:</p>
<pre><code>subdir\file.ext
</code></pre>
<p>So the absolute path of the file will be:</p>
<pre><code>\Device\HarddiskVolume2\directory\subdir\file.ext
</code></pre>
<p>This is the only type of relative path understood by the kernel. In the NT kernel <code>.</code> and <code>..</code> have no special meaning and can be regular files or directories (but almost certainly shouldn't be).</p>
<h3 id="device-paths"><a class="header" href="#device-paths">Device paths</a></h3>
<p>When resolving paths the Object Manager itself is actually only responsible for finding the devices it manages. You can see this using <a href="https://github.com/hfiref0x/WinObjEx64">WinObjEx64</a>. Note that in the path <code>\Device\HarddiskVolume4</code> is not a directory.</p>
<p><img src="images/Device.png" alt="NT Devices" /></p>
<p>What happens is the Object Manager resolves the device path and then the rest of the path is given to the device to resolve itself. For example, given the path:</p>
<pre><code>\Device\HarddiskVolume2\directory\subdir\file.ext
</code></pre>
<p>The Object Manager will find <code>\Device\HarddiskVolume2</code> and pass it the path <code>\directory\subdir\file.ext</code> which the device may resolve to a resource. Alternatively the device can give a new path back to the Object Manager and ask it to &quot;reparse&quot; the path (i.e. discard the old path and resolve the new path).</p>
<p>In effect this means that devices are free to resolve paths however they like. However, filesystem drivers should usually stick to <a href="Filesystems.html">filesystem conventions</a> even though this is not enforced by the kernel. If they do not then users of the Win32 APIs may be unable to properly use the filesystem.</p>
<h2 id="object-manager-symlinks"><a class="header" href="#object-manager-symlinks">Object Manager Symlinks</a></h2>
<p>Device paths such as <code>\Device\HarddiskVolume2</code> are all very well but often you want a more meaningful or consistent name. To this end NT supports symbolically linking from one path to another. Many of these meaningful names will be collected into a single NT folder: <code>\??</code>.</p>
<p>For example, to access a drive by its GUID you can use:</p>
<pre><code>\??\Volume{a2f2fe4e-fb6b-4442-9244-1342c61c4067}
</code></pre>
<p>Or you can use a friendly drive name:</p>
<pre><code>\??\C:
</code></pre>
<p>The <code>:</code> here has no special meaning. It's just part of the symlink name.</p>
<h2 id="the--folder"><a class="header" href="#the--folder">The <code>\??</code> folder</a></h2>
<p>The <code>\??</code> folder is not actually a normal directory. Instead it's a virtual folder that merges two directories:</p>
<ul>
<li>The <code>\GLOBAL??</code> directory. This contains symlinks common to all usesr. <img src="images/Global.png" alt="Global Dos Devices" /></li>
<li>A per-user <code>DosDevices</code> directory. This contains the user's symlinks so the exact path depends on the user. In the following image it's <code>\Sessions\0\DosDevices\00000000-00053ce2</code> <img src="images/Session%20DosDevices.png" alt="User Dos Devices" /></li>
</ul>
<h2 id="security"><a class="header" href="#security">Security</a></h2>
<p>Win32 paths such as:</p>
<pre><code>R:\path\to\file.ext
</code></pre>
<p>Will resolve to the NT path:</p>
<pre><code>\??\R:\path\to\file.ext
</code></pre>
<p>As <code>R:</code> is symlink, this means that there is a symlink at the root of the win32 path. Users do not need any special permission to add or remove symlinks (aka &quot;Dos Devices&quot;). The potential security implications are somewhat mitigated by the fact that users can only affect their own Dos Devices directory and not <code>\Global??</code> or that of other users. That said, paths are just strings so can easily cross user boundaries (e.g. when a process impersonates another user so it can carry out operations in the context of that user).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="strings"><a class="header" href="#strings">Strings</a></h1>
<h2 id="encoding"><a class="header" href="#encoding">Encoding</a></h2>
<p>In Windows, all paths are treated as Unicode strings. However the Win32 API provides convinence functions to automatically convert the system encoding to UTF-16 (and vice versa). This helps to avoid the <a href="https://en.wikipedia.org/wiki/Mojibake">Mojibake</a> problem by only having one canonical encoding. The UTF-16 conversion happens before everything else so interpreting paths only needs to operate on UTF-16 strings.</p>
<h2 id="unicodestring"><a class="header" href="#unicodestring"><code>UnicodeString</code></a></h2>
<p>The NT kernel uses UTF-16 strings. Their definition is conceptually similar to Rust's <code>Vec&lt;u16&gt;</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct UnicodeString {
    length: u16,
    capacity: u16,
    buffer: *mut u16,
}
<span class="boring">}
</span></code></pre></pre>
<p>Note that these strings can contain nulls. However, if they do then they will not be useable by the Windows API.</p>
<p>Unlike Rust's <code>String</code>, the kernel will not check that the UnicodeString struct contains valid UTF-16. This means that it's possible for malicious applications to create file names with isolated surrogates (i.e. invalid Unicode).</p>
<h2 id="windows-api-strings"><a class="header" href="#windows-api-strings">Windows API Strings</a></h2>
<p>In the Win32 API there are generally two types of strings that applications can choose to use. Both are <code>NULL</code> terminated.</p>
<ul>
<li>Multibyte: <code>*mut u8</code></li>
<li>Wide: <code>*mut u16</code>.</li>
</ul>
<p>Multibyte strings are in whichever encoding is set by the user or system. Windows will automatically convert to and from a UTF-16 <code>UnicodeString</code> as needed. If a Multibyte string contains bytes that are invalid for that encoding then they may be replaced when converting to UTF-16.</p>
<p>Recent versions of Windows also have the UTF-8 local encoding which, like other local encodings, is lossily converted to and from UTF-16.</p>
<p>Wide strings are UTF-16 and are put into a <code>UnicodeString</code> struct without being checked, except to get the length. So again it's possible for the string to contain invalid Unicode.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="filesystems"><a class="header" href="#filesystems">Filesystems</a></h1>
<p>While the kernel allows almost anything in component names, filesystems may be more restrictive. For example, an <a href="Object%20Manager.html">NT path</a> can include a component called <code>C:</code> but a filesystem may not allow you to create a directory with that name.</p>
<p>Microsoft's filesystem drivers will typically not allow the following characters in component names:</p>
<table><thead><tr><th>Disallowed</th><th>Description</th></tr></thead><tbody>
<tr><td><code>\</code> <code>/</code></td><td>Path seperators</td></tr>
<tr><td><code>:</code></td><td>Dos drive and NTFS file stream separator</td></tr>
<tr><td><code>*</code> <code>?</code></td><td>Wildcards</td></tr>
<tr><td><code>&lt;</code> <code>&gt;</code> <code>&quot;</code></td><td>DOS wildcards</td></tr>
<tr><td><code>|</code></td><td>Pipe</td></tr>
<tr><td><code>NUL</code> to <code>US</code></td><td>ASCII control codes; aka Unicode C0 control codes (U+0000 to U+001F inclusive). Note that <code>DEL</code> (U+007F) is allowed.</td></tr>
</tbody></table>
<p>Each component in a path is currently limited to 255 UTF-16 code units. However, it may not be safe to rely on this.</p>
<p>Filesystem paths may or may not be case sensitive. In Windows they are typically case insensitive but this cannot always be assumed. In some circumstances case sensitivity can even differ on a per directory basis.</p>
<p>While filesystems could be more relaxed about valid characters, path separators (<code>\/</code>) and wildcards (<code>*?&lt;&gt;&quot;</code>) must be disallowed in normal filesystems. Otherwise some Win32 APIs will be unusable in some situations.</p>
<h2 id="file-streams"><a class="header" href="#file-streams">File streams</a></h2>
<p>The above disallowed characters applies to component names but NTFS understands an additional syntax: file streams. Each file (including directories) can have multiple streams of data. You can address them like so:</p>
<pre><code>file.ext:stream_name
</code></pre>
<p>Which is also equivalent to:</p>
<pre><code>file.ext:stream_name:$DATA
</code></pre>
<p>The stream name cannot contain a <code>NULL</code> (<code>0x0000</code>) or have the characters <code>\</code>, <code>/</code>, <code>:</code>. Like path components, it's limited to 255 UTF-16 code units.</p>
<p>The <code>$DATA</code> part of the stream identifier is a stream type. Valid types are assigned by Microsoft and always start with a <code>$</code>. If not specified, the type defaults to <code>$DATA</code>.</p>
<p>Directories also have a special directory stream type and will default to it if no stream name is given. For example:</p>
<pre><code>dir_name
</code></pre>
<p>Is equivalent to:</p>
<pre><code>dir_name:$I30:$INDEX_ALLOCATION
</code></pre>
<h2 id="special-filesystems"><a class="header" href="#special-filesystems">Special filesystems</a></h2>
<p>There are some special devices which accept paths but aren't true filesystem. For example, the <code>NUL</code> device will claim every path exists (even those that are usually invalid). The <code>PIPE</code> device simply treats paths strings. It does not have actual directories, although it does treat some prefixes specially (e.g. <code>LOCAL\</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="win32-paths-1"><a class="header" href="#win32-paths-1">Win32 Paths</a></h1>
<p>The Win32 API is built as a layer on top of the NT kernel. It implements an API that was originally built for those familiar with Win16 and DOS so it doesn't directly deal with NT paths. Instead it converts Win32 paths to NT paths before calling the kernel.</p>
<p>Essentially Win32 paths are a user-space compatibility layer.</p>
<h3 id="absolute-win32-paths-1"><a class="header" href="#absolute-win32-paths-1">Absolute Win32 paths</a></h3>
<p>All absolute paths start with a root. On *nix the root is <code>/</code>. For the NT kernel it's <code>\</code>. In contrast, Win32 has four types of root and they're all longer than one character.</p>
<ul>
<li><code>C:\</code>, <code>D:\</code>, <code>E:\</code>, etc. The first letter is a (case insensitive) drive letter that can be any ascii letter from <code>A</code> to <code>Z</code>.</li>
<li><code>\\server\share\</code> where <code>server</code> is the name of the server and <code>share</code> is the name of the shared directory. It is used to access a shared directory on a server therefore you must always specifiy both a server name and share name.</li>
<li><code>\\.\</code>. These are typically used to access devices other than drives or server shares (e.g. named pipes). So they are not usually filesystem paths.</li>
<li><code>\\?\</code>. These can be used to access any type of device.</li>
</ul>
<p>The following table shows each type and an example of how the Win32 root is converted to a kernel path.</p>
<table><thead><tr><th>Type</th><th>Win32 path</th><th>Kernel path</th></tr></thead><tbody>
<tr><td>Drive</td><td><code>C:\Windows</code></td><td><code>\??\C:\Windows</code></td></tr>
<tr><td><abbr title="Universal Naming Convention">UNC</abbr></td><td><code>\\server\share\file</code></td><td><code>\??\UNC\server\share\file</code></td></tr>
<tr><td>Device</td><td><code>\\.\PIPE\name</code></td><td><code>\??\PIPE\name</code></td></tr>
<tr><td>Verbatim</td><td><code>\\?\C:\Windows</code><br><code>\\?\UNC\server\share\file</code><br><code>\\?\PIPE\name</code></td><td><code>\??\C:\Windows</code><br><code>\??\UNC\server\share\file</code><br><code>\??\PIPE\name</code></td></tr>
</tbody></table>
<p>From the table above it looks like device paths and verbatim paths work the same way. However, that's only because I left off a column: the namespace. The namespace determines what happens to the part of the path after the root. </p>
<table><thead><tr><th>Type</th><th>Namespace</th><th>Example</th></tr></thead><tbody>
<tr><td>Drive</td><td>Win32</td><td><code>C:\Windows</code></td></tr>
<tr><td><abbr title="Universal Naming Convention">UNC</abbr></td><td>Win32</td><td><code>\\server\share\file</code></td></tr>
<tr><td>Device</td><td>Win32</td><td><code>\\.\PIPE\name</code></td></tr>
<tr><td>Verbatim</td><td>NT</td><td><code>\\?\C:\Windows</code><br><code>\\?\UNC\server\share\file</code><br><code>\\?\PIPE\name</code></td></tr>
</tbody></table>
<p>The next two sections will explain the effects the namespace has.</p>
<h3 id="nt-namespace"><a class="header" href="#nt-namespace">NT namespace</a></h3>
<p>Paths in the NT namespace are passed almost directly to the kernel without any transformations or substitutions.</p>
<p>The only Win32 paths in the NT namespace are verbatim paths (i.e. those that start with <code>\\?\</code>). When converting a verbatim path to a kernel path, all that happens is the root <code>\\?\</code> is changed to the kernel path <code>\??\</code>. The rest of the path is left untouched. See <a href="./NT.html">NT Kernel Paths</a> for more on kernel paths.</p>
<p>Note that this is the only way to use kernel paths in the Win32 API. If you start a path with <code>\??\</code> or <code>\Device\</code> then it can have very different results.</p>
<h3 id="win32-namespace"><a class="header" href="#win32-namespace">Win32 namespace</a></h3>
<p>This section applies to all Win32 paths except for verbatim paths (those that start with <code>\\?\</code>).</p>
<p>When converting a Win32 path to a kernel path there are additional transformations and restrictions that are applied to DOS drive paths, UNC paths and Device paths. Some of these transformations are useful while others are an unfortunate holdover from DOS or early Windows.</p>
<p>Win32 namespaced paths are restricted to a length less than 260 UTF-16 code units. This restriction can be lifted on newer versions of Windows 10 but it requires both the user and the application to opt in.</p>
<p>When paths are in this namespace, one of two transformations may happen:</p>
<ul>
<li>If the path is a special DOS device name then a device path is returned. See <a href="./Special%20Dos%20Device%20Names.html">Special Dos Device Names</a> for details.</li>
<li>Otherwise the following transformations are applied:
<ul>
<li>First, all occurences of <code>/</code> are changed to <code>\</code>.</li>
<li>All path components consisting of only a single <code>.</code> are removed.</li>
<li>A sequence containing more than one <code>\</code> is replaced with a single <code>\</code>. E.g. <code>\\\</code> is collapsed to <code>\</code>.</li>
<li>All <code>..</code> path components will be removed along with their parent component. The Win32 root (e.g. <code>C:\</code>, <code>\\server\share</code>, <code>\\.\</code>) will never be removed.</li>
<li>If a component name ends with a <code>.</code> then the final <code>.</code> is removed, unless another <code>.</code> comes before it. So <code>dir.</code> becomes <code>dir</code> but <code>dir..</code> remains as it is. I'm sure there's a reason for this.</li>
<li>For the filename only (aka the last component), all trailing dots and spaces are stripped.</li>
</ul>
</li>
</ul>
<p>For example, this:</p>
<pre><code>C:/path////../../../to/.////file.. ..
</code></pre>
<p>Is changed to:</p>
<pre><code>C:\to\file
</code></pre>
<p>Which becomes the kernel path:</p>
<pre><code>\??\C:\to\file
</code></pre>
<p>This transformation all happens without touching the filesystem.</p>
<h3 id="relative-win32-paths-1"><a class="header" href="#relative-win32-paths-1">Relative Win32 paths</a></h3>
<p>Relative paths are usually resolved relative to the current directory. The current directory is a global mutable value that stores an absolute Win32 path to an existing directory. The current directory only supports DOS drive paths (e.g. <code>C:\</code>) and UNC paths (e.g. <code>\\server\share</code>). Using any other path type when setting the current directory is liable to break relative paths therefore verbatim paths (<code>\\?\</code>) should not be used.</p>
<p>There are three categories of relative Win32 paths.</p>
<table><thead><tr><th>Type</th><th>Examples</th></tr></thead><tbody>
<tr><td>Path Relative</td><td><code>file.ext</code><br><code>.\file.ext</code><br><code>..\file.ext</code></td></tr>
<tr><td>Root Relative</td><td><code>\file.ext</code></td></tr>
<tr><td>Drive Relative</td><td><code>D:file.ext</code></td></tr>
</tbody></table>
<p>Although Path Relative forms come in three flavours there are really only two. <code>file.txt</code> is interpreted exactly the same way as <code>.\file.txt</code> (see Win32 namespace). However, the <code>.\</code> prefix can help to avoid ambiguities introduced by drive relative paths.</p>
<p>Drive Relative paths are interpreted as being relative to the specified drive's current directory (note: usually only the command prompt has per drive current directories). Root relative are relative to the root of the current directory.</p>
<p>Drive Relative and Root Relative paths should be avoided whenever possible. Developers and users rarely understand how they're resolved so their results can be surprising. Additionally the Drive Relative paths syntax introduces ambiguity with file streams.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="special-dos-device-names-1"><a class="header" href="#special-dos-device-names-1">Special DOS Device names</a></h1>
<p>In the Win32 namespace a path that matches the name of a special DOS device may be resolved to that device instead of to a file path. For example, that path:</p>
<pre><code>COM1
</code></pre>
<p>Will resolve to:</p>
<pre><code>\\.\COM1
</code></pre>
<p>Which becomes the kernel path:</p>
<pre><code>\??\COM1
</code></pre>
<p>These are the DOS device names that get the path replaced:</p>
<ul>
<li><code>AUX</code></li>
<li><code>CON</code></li>
<li><code>CONIN$</code></li>
<li><code>CONOUT$</code></li>
<li><code>COM1</code>, <code>COM2</code>, <code>COM3</code>, <code>COM4</code>, <code>COM5</code>, <code>COM6</code>, <code>COM7</code>, <code>COM8</code>, <code>COM9</code>, <code>COM²</code>, <code>COM³</code>, <code>COM¹</code></li>
<li><code>LPT1</code>, <code>LPT2</code>, <code>LPT3</code>, <code>LPT4</code>, <code>LPT5</code>, <code>LPT6</code>, <code>LPT7</code>, <code>LPT8</code>, <code>LPT9</code>, <code>LPT²</code>, <code>LPT³</code>, <code>LPT¹</code></li>
<li><code>NUL</code></li>
<li><code>PRN</code></li>
</ul>
<p>However the algorithm for matching device names is not as simple as a direct comparison and also depends on the OS version.</p>
<h2 id="windows-11"><a class="header" href="#windows-11">Windows 11</a></h2>
<p>Windows 11 greatly simplified how these device names are handled compared to earlier versions of Windows.</p>
<p>To test if a path matches a special dos device, it's as if the following steps were taken before comparing:</p>
<ol>
<li>ASCII letters are uppercased</li>
<li>trailing dots (<code>.</code>) and spaces (<code> </code>) are removed</li>
</ol>
<p>So <code>cOm1..  ..</code> is interpreted as <code>\\.\COM1</code> but <code>.\COM1</code> isn't.</p>
<p>The one remaining complication is the <code>NUL</code> device. If this appears in the filename (aka last component) of an absolute DOS drive or a relative path then the filename itself will be compared using the steps above. But this only happens if the parent directory actually exists thus it's as though every directory has a virtual <code>NUL</code> file.</p>
<p>So the following paths are interpreted as <code>\\.\NUL</code> if their parent directory exists:</p>
<pre><code>C:\path\to\nul
</code></pre>
<p>Again, this only applies to <code>NUL</code> so <code>C:\path\to\COM1</code> will be treated as a normal file path.</p>
<h2 id="windows-10-and-earlier"><a class="header" href="#windows-10-and-earlier">Windows 10 and earlier</a></h2>
<p>If a path is an absolute DOS drive or a relative path and if a filename (aka the final component) matches one of the special DOS device name then the path is ignored and replaced with that DOS device. For example:</p>
<pre><code>C:\path\to\COM1
</code></pre>
<p>Gets translated to:</p>
<pre><code>\\.\COM1
</code></pre>
<p>It's as if the following steps were applied to the file name before comparing:</p>
<ol>
<li>ASCII letters are uppercased</li>
<li>anything after a <code>.</code> and the <code>.</code> itself are removed</li>
<li>any trailing spaces (<code> </code>) are stripped.</li>
</ol>
<p>For example, these filenames are all interpreted as <code>\\.\COM1</code>:</p>
<ul>
<li>&quot;<code>COM1.ext</code>&quot;</li>
<li>&quot;<code>COM1     </code>&quot;</li>
<li>&quot;<code>COM1 . .ext</code>&quot;</li>
</ul>
<p>When opening a file path such as <code>C:\Test\COM1</code>, it will only resolve to <code>\\.\COM1</code> if the parent directory <code>C:\Test</code> exists. Otherwise opening the file will fail with an invalid path error.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
